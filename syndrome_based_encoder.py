import numpy as np  # type: ignore
import pandas as pd  # type: ignore
from typing import List, Tuple, Optional, Dict
import random
import syndrome_lut

# Configuration
MODE = "min_flips"  # Options: "min_flips" or "min_weight"


def create_redundancy_matrix() -> np.ndarray:
    """Create and return the user-provided redundancy matrix H_V (6×13)"""
    return np.array([
        [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1],
        [0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
        [0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0],
        [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1],
        [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0]
    ])


def generate_random_mask(num_bits: int) -> np.ndarray:
    """Generate random binary mask avoiding all zeros"""
    while True:
        mask = np.random.randint(0, 2, num_bits)
        if np.any(mask):  # Ensure not all zeros
            return mask


def generate_HU_from_HV(H_V: np.ndarray, k: int = 32, rng_seed: Optional[int] = None) -> np.ndarray:
    """Build H_U as GF(2) linear combinations of H_V columns"""
    if rng_seed is not None:
        np.random.seed(rng_seed)
    
    r = H_V.shape[0]  # Number of rows (6)
    n_V = H_V.shape[1]  # Number of columns in H_V (13)
    
    H_U = np.zeros((r, k), dtype=int)
    
    for col in range(k):
        # Generate random mask for selecting H_V columns
        mask = generate_random_mask(n_V)
        
        # XOR the selected columns of H_V
        result = np.zeros(r, dtype=int)
        for i in range(n_V):
            if mask[i]:
                result = (result + H_V[:, i]) % 2
        
        H_U[:, col] = result
    
    return H_U


def syndrome_to_key(syndrome: np.ndarray) -> str:
    """Convert syndrome bit vector to string key for dictionary"""
    return ''.join(map(str, syndrome))


def key_to_syndrome(key: str) -> np.ndarray:
    """Convert string key back to syndrome bit vector"""
    return np.array([int(bit) for bit in key])


def precompute_coset_leaders(H_V: np.ndarray) -> None:
    """Precompute coset leaders: minimum-weight v for each syndrome s = H_V * v^T"""
    n_V = H_V.shape[1]  # Number of columns in H_V (13)
    
    leaders = {}
    
    # Iterate all possible v masks (2^13 combinations)
    for i in range(1 << n_V):
        # Convert integer to binary mask
        v_bits = np.array([(i >> j) & 1 for j in range(n_V)])
        
        # Compute syndrome s = H_V * v^T
        s = (H_V @ v_bits) % 2
        
        # Convert syndrome to string key
        s_key = syndrome_to_key(s)
        
        # Calculate weight of v
        weight = np.sum(v_bits)
        
        # Store minimum-weight v for this syndrome (tie-break by smaller index)
        if s_key not in leaders or weight < leaders[s_key][1] or (weight == leaders[s_key][1] and i < leaders[s_key][2]):
            leaders[s_key] = (v_bits, weight, i)
    
    # Write coset leaders to syndrome_lut.py
    with open('syndrome_lut.py', 'w') as f:
        f.write("# Coset Leaders Lookup Table\n")
        f.write("# This file is generated by syndrome_based_encoder.py\n")
        f.write("# Format: {syndrome_string: v_bits_array}\n\n")
        f.write("import numpy as np # type: ignore\n\n")
        f.write("COSET_LEADERS = {\n")
        
        for s_key, (v_bits, _, _) in leaders.items():
            v_bits_str = f"np.array({v_bits.tolist()})"
            f.write(f"    '{s_key}': {v_bits_str},\n")
        
        f.write("}\n\n")
        f.write("def get_leader(s_key: str):\n")
        f.write("    \"\"\"Get coset leader for given syndrome\"\"\"\n")
        f.write("    return COSET_LEADERS.get(s_key, None)\n")
    
    # Reload the module to get the updated lookup table
    import importlib
    importlib.reload(syndrome_lut)


def syndrome_of_u(H_U: np.ndarray, u_bits: np.ndarray) -> np.ndarray:
    """Compute syndrome s = H_U * u^T"""
    return (H_U @ u_bits) % 2


def get_leader_for_syndrome(syndrome_bits: np.ndarray) -> np.ndarray:
    """Get coset leader for given syndrome bits"""
    s_key = syndrome_to_key(syndrome_bits)
    return syndrome_lut.get_leader(s_key)


def update_with_previous_state(u_bits: np.ndarray, prev_syndrome: np.ndarray, prev_v: np.ndarray, H_U: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """Compute v using Δ-syndrome approach with previous state"""
    # Compute current syndrome s_curr = H_U @ u_bits
    s_curr = syndrome_of_u(H_U, u_bits)
    
    # Compute delta syndrome: prev_syndrome XOR s_curr
    delta_s = prev_syndrome ^ s_curr
    
    # Lookup delta_v = get_leader_for_syndrome(delta_s)
    delta_v = get_leader_for_syndrome(delta_s)
    
    # Set v_curr = prev_v XOR delta_v
    v_curr = prev_v ^ delta_v
    
    return s_curr, v_curr


def encode_min_weight(u_bits: np.ndarray, H_U: np.ndarray) -> np.ndarray:
    """Encode u using minimum-weight approach (stateless)"""
    # Compute syndrome s_curr = H_U @ u_bits
    s_curr = syndrome_of_u(H_U, u_bits)
    
    # Return v = get_leader_for_syndrome(s_curr)
    return get_leader_for_syndrome(s_curr)


def encode(u_bits: np.ndarray, H_U: np.ndarray, state: Optional[Dict] = None) -> Dict:
    """Encoder façade with mode switch and state threading"""
    if MODE == "min_flips":
        if state is None:
            # Initialize state: prev_syndrome = zeros(6), prev_v = zeros(13)
            prev_syndrome = np.zeros(6, dtype=int)
            prev_v = np.zeros(13, dtype=int)
        else:
            prev_syndrome = state["prev_syndrome"]
            prev_v = state["prev_v"]
        
        # Update with previous state
        s_curr, v_curr = update_with_previous_state(u_bits, prev_syndrome, prev_v, H_U)
        
        return {
            "u": u_bits,
            "v": v_curr,
            "syndrome": s_curr,
            "state": {"prev_syndrome": s_curr, "prev_v": v_curr}
        }
    
    elif MODE == "min_weight":
        # Stateless encoding
        s_curr = syndrome_of_u(H_U, u_bits)
        v = get_leader_for_syndrome(s_curr)
        
        return {
            "u": u_bits,
            "v": v,
            "syndrome": s_curr
        }
    
    else:
        raise ValueError(f"Unknown mode: {MODE}")


def construct_H_matrix(H_U: np.ndarray, H_V: np.ndarray) -> np.ndarray:
    """Construct complete H matrix by concatenating [H_U | H_V]"""
    return np.column_stack([H_U, H_V])


def display_H_matrix(H_matrix: np.ndarray) -> None:
    """Display the H matrix in a formatted way using pandas"""
    print("H Matrix:")
    print("=" * 80)
    
    H_df = pd.DataFrame(
        H_matrix,
        index=[f'Row {i+1}' for i in range(6)],
        columns=[f'Col {i+1}' for i in range(45)]
    )
    print(H_df)
    print(f"\nStructure: Info part (Col 1-32) | Redundancy part (Col 33-45)")


def test_random_info_words(H_U: np.ndarray,
                          num_tests: int = 500) -> List[int]:
    """Test random info words and return list of transition costs"""
    print(f"\nTesting {num_tests} random info words with {MODE} encoding...")
    
    results = []
    state = None
    
    for _ in range(num_tests):
        # Generate random info word u
        u_bits = np.random.randint(0, 2, 32)
        
        # Encode using the new encoder
        result = encode(u_bits, H_U, state)
        
        if MODE == "min_flips":
            # For min_flips mode, compute transition cost
            if state is None:
                # First iteration: transition cost is weight of v
                transition_cost = np.sum(result["v"])
            else:
                # Compute transition cost: XOR between previous and current v
                transition_cost = np.sum(result["v"] ^ state["prev_v"])
            
            results.append(transition_cost)
            state = result["state"]
        else:
            # For min_weight mode, just track the weight
            weight = np.sum(result["v"])
            results.append(weight)
    
    return results


def display_summary(results: List[int]) -> None:
    """Display summary statistics of the test results"""
    print(f"\nSummary:")
    print("=" * 30)
    print(f"Total info words tested: {len(results)}")
    if MODE == "min_flips":
        print(f"Maximum transition cost: {max(results)}")
        print(f"Minimum transition cost: {min(results)}")
        print(f"Average transition cost: {np.mean(results):.2f}")
    else:
        print(f"Maximum weight: {max(results)}")
        print(f"Minimum weight: {min(results)}")
        print(f"Average weight: {np.mean(results):.2f}")


def main():
    """Main function to orchestrate the H matrix analysis"""
    # Step 1: Create redundancy matrix H_V
    H_V = create_redundancy_matrix()
    
    # Step 2: Generate H_U as GF(2) linear combinations of H_V
    H_U = generate_HU_from_HV(H_V, k=32, rng_seed=42)
    
    # Step 3: Precompute coset leaders and write to file
    precompute_coset_leaders(H_V)
    
    # Step 4: Construct complete H matrix
    H = construct_H_matrix(H_U, H_V)
    
    # Step 5: Display the H matrix
    display_H_matrix(H)
    
    # Step 6: Test random info words
    results = test_random_info_words(H_U)

    # Step 7: Display summary
    display_summary(results)


if __name__ == "__main__":
    main()


