import numpy as np  # type: ignore
import pandas as pd  # type: ignore
from typing import List, Tuple, Optional
import syndrome_lut


def create_redundancy_matrix() -> np.ndarray:
    """Create and return the user-provided redundancy matrix H_V (6×13) with columns sorted by value"""
    # Column values: [2, 3, 15, 19, 20, 24, 25, 29, 35, 44, 48, 54, 62]
    return np.array([
        [0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0],
        [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1],
        [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1],
        [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1],
        [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1],
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
    ])


def generate_random_mask(num_bits: int) -> np.ndarray:
    """Generate random binary mask avoiding all zeros"""
    while True:
        mask = np.random.randint(0, 2, num_bits)
        if np.any(mask):  # Ensure not all zeros
            return mask


def generate_HU_from_HV(H_V: np.ndarray, k: int = 32, rng_seed: Optional[int] = None) -> np.ndarray:
    """Build H_U as GF(2) linear combinations of H_V columns with UNIQUE columns.

    - Enforces uniqueness of the 6-bit column vectors.
    - Optionally sorts columns by their 6-bit LSB-first numeric value.
    """
    if rng_seed is not None:
        np.random.seed(rng_seed)
    
    r = H_V.shape[0]  # Number of rows (6)
    n_V = H_V.shape[1]  # Number of columns in H_V (13)
    
    # Collect unique columns
    unique_cols: List[np.ndarray] = []
    seen_keys = set()

    attempts = 0
    max_attempts = 20 * k  # generous cap
    while len(unique_cols) < k and attempts < max_attempts:
        attempts += 1
        # Generate random mask for selecting H_V columns
        mask = generate_random_mask(n_V)

        # XOR the selected columns of H_V
        result = np.zeros(r, dtype=int)
        for i in range(n_V):
            if mask[i]:
                result = (result + H_V[:, i]) % 2

        # Skip all-zero column
        if not np.any(result):
            continue

        key = tuple(result)
        if key in seen_keys:
            continue
        seen_keys.add(key)
        unique_cols.append(result)


    # Stack into matrix (6 × k)
    H_U = np.stack(unique_cols, axis=1)

    # Compute LSB-first 6-bit numeric value for each column and sort ascending
    col_values: List[Tuple[int, int]] = []
    for c in range(k):
        val = 0
        for r_idx in range(r):
            val |= (int(H_U[r_idx, c]) << r_idx)
        col_values.append((val, c))
    col_values.sort()
    sorted_indices = [c for _, c in col_values]
    H_U = H_U[:, sorted_indices]
    
    return H_U


def precompute_coset_leaders(H_V: np.ndarray) -> None:
    """Precompute coset leaders: minimum-weight v for each syndrome s = H_V * v^T"""
    n_V = H_V.shape[1]  # Number of columns in H_V (13)
    
    leaders = {}
    
    # Iterate all possible v masks (2^13 combinations)
    for i in range(1 << n_V):
        # Convert integer to binary mask
        v_bits = np.array([(i >> j) & 1 for j in range(n_V)])
        
        # Compute syndrome s = H_V * v^T
        s = (H_V @ v_bits) % 2
        
        # Convert syndrome to tuple key
        s_key = tuple(s)
        
        # Calculate weight of v
        weight = np.sum(v_bits)
        
        # Store minimum-weight v for this syndrome (tie-break by smaller index)
        if s_key not in leaders or weight < leaders[s_key][1] or (weight == leaders[s_key][1] and i < leaders[s_key][2]):
            leaders[s_key] = (v_bits, weight, i)
    
    # Write coset leaders to syndrome_lut.py
    with open('syndrome_lut.py', 'w') as f:
        f.write("# Coset Leaders Lookup Table\n")
        f.write("# This file is generated by syndrome_based_encoder.py\n")
        f.write("# Format: {syndrome_string: v_bits_array}\n\n")
        f.write("import numpy as np # type: ignore\n\n")
        f.write("COSET_LEADERS = {\n")
        
        for s_key, (v_bits, _, _) in leaders.items():
            v_bits_str = f"np.array({v_bits.tolist()})"
            f.write(f"    {s_key}: {v_bits_str},\n")
        
        f.write("}\n\n")
        f.write("def get_leader(s_key: tuple):\n")
        f.write("    \"\"\"Get coset leader for given syndrome\"\"\"\n")
        f.write("    return COSET_LEADERS.get(s_key, None)\n")
    
    # Reload the module to get the updated lookup table
    import importlib
    importlib.reload(syndrome_lut)


def encode(u_bits: np.ndarray, H_U: np.ndarray, s_prev: np.ndarray, v_prev: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """Compute v using Δ-syndrome approach with previous state"""
    # Compute current syndrome s_curr = H_U @ u_bits
    s_curr = (H_U @ u_bits) % 2
    
    # Compute delta syndrome: s_prev XOR s_curr
    delta_s = s_prev ^ s_curr
    
    # Lookup delta_v = get_leader(delta_s)
    delta_v = syndrome_lut.get_leader(tuple(delta_s))
    
    # Set v_curr = prev_v XOR delta_v
    v_curr = v_prev ^ delta_v
    
    return s_curr, v_curr


def display_H_matrix(H_matrix: np.ndarray) -> None:
    """Display the H matrix in a formatted way using pandas"""
    print("H Matrix:")
    print("=" * 80)
    
    H_df = pd.DataFrame(
        H_matrix,
        index=[f'Row {i+1}' for i in range(6)],
        columns=[f'Col {i+1}' for i in range(45)]
    )
    print(H_df)
    print(f"\nStructure: Info part (Col 1-32) | Redundancy part (Col 33-45)")


def test_random_info_words(H_U: np.ndarray,
                          num_tests: int = 500) -> List[int]:
    """Test random info words and return list of transition costs"""
    print(f"\nTesting {num_tests} random info words with Δ-syndrome encoding...")
    
    results = []
    
    # Initialize s and v with zeros
    s_prev = np.zeros(6, dtype=int)
    v_prev = np.zeros(13, dtype=int)
    
    for _ in range(num_tests):
        # Generate random info word u
        u = np.random.randint(0, 2, 32)
        
        # Encode using the new encoder
        s_curr, v_curr = encode(u, H_U, s_prev, v_prev)
        
        # Compute transition cost: XOR between previous and current v
        transition_cost = np.sum(v_curr ^ v_prev)
        
        results.append(transition_cost)
        v_prev = v_curr
        s_prev = s_curr
    
    return results


def display_summary(results: List[int]) -> None:
    """Display summary statistics of the test results"""
    print(f"\nSummary:")
    print("=" * 30)
    print(f"Total info words tested: {len(results)}")
    print(f"Maximum transition cost: {max(results)}")


def main():
    """Main function to orchestrate the H matrix analysis"""
    # Step 1: Create redundancy matrix H_V
    H_V = create_redundancy_matrix()
    
    # Step 2: Generate H_U as GF(2) linear combinations of H_V
    H_U = generate_HU_from_HV(H_V, rng_seed=42)
    
    # Step 3: Precompute coset leaders and write to file
    precompute_coset_leaders(H_V)
    
    # Step 4: Construct complete H matrix
    H = np.column_stack([H_U, H_V])
    
    # Step 5: Display the H matrix
    display_H_matrix(H)
    
    # Step 6: Test random info words
    results = test_random_info_words(H_U)

    # Step 7: Display summary
    display_summary(results)


if __name__ == "__main__":
    main()


